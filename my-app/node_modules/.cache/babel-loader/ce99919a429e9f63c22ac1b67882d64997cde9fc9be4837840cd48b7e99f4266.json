{"ast":null,"code":"import getAlphanumFromUnicodeRange from './getAlphanumFromUnicodeRange';\nimport makeAlphanumMaxlenComputer from './makeAlphanumMaxlenComputer';\nimport makeCSEngine from './makeCSEngine';\nimport makeCSRenderer from './makeCSRenderer';\nimport codepointLength from './utils/codepointLength';\nconst mod = (value, divisor) => (value % divisor + divisor) % divisor;\nfunction makeCSRendererFromFormatter(formatter) {\n  return makeCSRenderer(makeCSEngine(formatter));\n}\nfunction getMaxLenInSymbols(lens) {\n  let from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let to = arguments.length > 2 ? arguments[2] : undefined;\n  to = typeof to === 'number' ? to : lens.length;\n  return lens.slice(from, to + 1).reduce((p, c) => Math.max(p, c), 0);\n}\nfunction numeric(renderer, length) {\n  return renderer.withMaxLengthComputer(makeAlphanumMaxlenComputer(length, false)).withNegative('-');\n}\nfunction alphabetic(renderer, length) {\n  return renderer.withMaxLengthComputer(makeAlphanumMaxlenComputer(length, true)).withRange(1, Infinity);\n}\n/**\n * A static object to build counter style renderers.\n * See {@link CounterStyleStatic}.\n *\n * @public\n */\nconst CounterStyle = Object.freeze({\n  raw: formatter => {\n    return makeCSRendererFromFormatter(formatter);\n  },\n  cyclic: function () {\n    for (var _len = arguments.length, symbols = new Array(_len), _key = 0; _key < _len; _key++) {\n      symbols[_key] = arguments[_key];\n    }\n    const symbolLenghts = symbols.map(codepointLength);\n    const maxLen = getMaxLenInSymbols(symbolLenghts);\n    const renderer = symbols.length === 1 ? makeCSRendererFromFormatter(() => symbols[0]) : makeCSRendererFromFormatter(index => symbols[mod(index - 1, symbols.length)]);\n    return renderer.withMaxLengthComputer((min, max) => {\n      return maxLen === 1 || max - min + 1 >= symbols.length ? maxLen : getMaxLenInSymbols(symbolLenghts, min - 1, max - 1);\n    });\n  },\n  fixed: function () {\n    for (var _len2 = arguments.length, symbols = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      symbols[_key2] = arguments[_key2];\n    }\n    const symbolLenghts = symbols.map(codepointLength);\n    const maxLen = getMaxLenInSymbols(symbolLenghts);\n    return makeCSRendererFromFormatter(index => symbols[index - 1]).withRange(1, symbols.length).withMaxLengthComputer((min, max) => {\n      return maxLen === 1 ? maxLen : getMaxLenInSymbols(symbolLenghts, min - 1, max - 1);\n    });\n  },\n  symbolic: function () {\n    for (var _len3 = arguments.length, symbols = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      symbols[_key3] = arguments[_key3];\n    }\n    return makeCSRendererFromFormatter(index => symbols[mod(index - 1, symbols.length)].repeat(Math.ceil(index / symbols.length))).withRange(1, Infinity).withMaxLengthComputer((min, max, defaultCmp) => {\n      // Just iterate over the last n elements until max, with n the number\n      // of symbols.\n      return defaultCmp(max < symbols.length ? min : max - symbols.length, max);\n    });\n  },\n  alphabetic: function () {\n    for (var _len4 = arguments.length, symbols = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      symbols[_key4] = arguments[_key4];\n    }\n    return alphabetic(makeCSRendererFromFormatter(index => {\n      let result = '';\n      while (index > 0) {\n        index--;\n        result = symbols[mod(index, symbols.length)] + result;\n        index = Math.floor(index / symbols.length);\n      }\n      return result;\n    }), symbols.length);\n  },\n  numeric: function () {\n    for (var _len5 = arguments.length, symbols = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      symbols[_key5] = arguments[_key5];\n    }\n    return numeric(makeCSRendererFromFormatter(index => {\n      if (index === 0) {\n        return symbols[0];\n      } else {\n        let result = '';\n        while (index > 0) {\n          result = symbols[mod(index, symbols.length)] + result;\n          index = Math.floor(index / symbols.length);\n        }\n        return result;\n      }\n    }), symbols.length);\n  },\n  numericFromUnicodeRange: (originUnicode, base) => {\n    return numeric(makeCSRendererFromFormatter(index => getAlphanumFromUnicodeRange(index, originUnicode, base, false)), base);\n  },\n  alphabeticFromUnicodeRange: (originUnicode, alphabetLen) => {\n    return alphabetic(makeCSRendererFromFormatter(index => {\n      return getAlphanumFromUnicodeRange(index, originUnicode, alphabetLen, true);\n    }), alphabetLen);\n  },\n  additive: symbols => {\n    const values = Object.keys(symbols).map(value => parseInt(value, 10)).sort((a, b) => b - a);\n    return makeCSRendererFromFormatter(index => {\n      if (index === 0) {\n        return symbols[0];\n      }\n      let result = '';\n      for (const value of values) {\n        if (index >= value && value > 0) {\n          const repeat = Math.floor(index / value);\n          result += symbols[value].repeat(repeat);\n          index -= repeat * value;\n        }\n      }\n      return index === 0 ? result : undefined;\n    }).withRange(values.length ? values[values.length - 1] : 0, 0 in symbols && values.length === 1 ? 0 : values.length ? Infinity : -1);\n  }\n});\nexport default CounterStyle;","map":{"version":3,"mappings":"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","names":["getAlphanumFromUnicodeRange","makeAlphanumMaxlenComputer","makeCSEngine","makeCSRenderer","codepointLength","mod","value","divisor","makeCSRendererFromFormatter","formatter","getMaxLenInSymbols","lens","from","to","length","slice","reduce","p","c","Math","max","numeric","renderer","withMaxLengthComputer","withNegative","alphabetic","withRange","Infinity","CounterStyle","Object","freeze","raw","cyclic","symbols","symbolLenghts","map","maxLen","index","min","fixed","symbolic","repeat","ceil","defaultCmp","result","floor","numericFromUnicodeRange","originUnicode","base","alphabeticFromUnicodeRange","alphabetLen","additive","values","keys","parseInt","sort","a","b","undefined"],"sources":["/home/shirin/Desktop/Frontend Assessment- Hacker Rank Clone /node_modules/@jsamr/counter-style/src/CounterStyle.ts"],"sourcesContent":["import getAlphanumFromUnicodeRange from './getAlphanumFromUnicodeRange';\nimport makeAlphanumMaxlenComputer from './makeAlphanumMaxlenComputer';\nimport makeCSEngine from './makeCSEngine';\nimport makeCSRenderer from './makeCSRenderer';\nimport type {\n  InitialCounterFormatter,\n  CounterStyleStatic,\n  CounterStyleRenderer\n} from './public-types';\nimport codepointLength from './utils/codepointLength';\n\nconst mod = (value: number, divisor: number) =>\n  ((value % divisor) + divisor) % divisor;\n\nfunction makeCSRendererFromFormatter(formatter: InitialCounterFormatter) {\n  return makeCSRenderer(makeCSEngine(formatter));\n}\n\nfunction getMaxLenInSymbols(lens: number[], from = 0, to?: number) {\n  to = typeof to === 'number' ? to : lens.length;\n  return lens.slice(from, to + 1).reduce((p, c) => Math.max(p, c), 0);\n}\n\nfunction numeric(renderer: CounterStyleRenderer, length: number) {\n  return renderer\n    .withMaxLengthComputer(makeAlphanumMaxlenComputer(length, false))\n    .withNegative('-');\n}\n\nfunction alphabetic(renderer: CounterStyleRenderer, length: number) {\n  return renderer\n    .withMaxLengthComputer(makeAlphanumMaxlenComputer(length, true))\n    .withRange(1, Infinity);\n}\n\n/**\n * A static object to build counter style renderers.\n * See {@link CounterStyleStatic}.\n *\n * @public\n */\nconst CounterStyle: Readonly<CounterStyleStatic> = Object.freeze({\n  raw: (formatter) => {\n    return makeCSRendererFromFormatter(formatter);\n  },\n  cyclic: (...symbols) => {\n    const symbolLenghts = symbols.map(codepointLength);\n    const maxLen = getMaxLenInSymbols(symbolLenghts);\n    const renderer =\n      symbols.length === 1\n        ? makeCSRendererFromFormatter(() => symbols[0])\n        : makeCSRendererFromFormatter(\n            (index) => symbols[mod(index - 1, symbols.length)]\n          );\n    return renderer.withMaxLengthComputer((min, max) => {\n      return maxLen === 1 || max - min + 1 >= symbols.length\n        ? maxLen\n        : getMaxLenInSymbols(symbolLenghts, min - 1, max - 1);\n    });\n  },\n  fixed: (...symbols) => {\n    const symbolLenghts = symbols.map(codepointLength);\n    const maxLen = getMaxLenInSymbols(symbolLenghts);\n    return makeCSRendererFromFormatter((index) => symbols[index - 1])\n      .withRange(1, symbols.length)\n      .withMaxLengthComputer((min, max) => {\n        return maxLen === 1\n          ? maxLen\n          : getMaxLenInSymbols(symbolLenghts, min - 1, max - 1);\n      });\n  },\n  symbolic: (...symbols) =>\n    makeCSRendererFromFormatter((index) =>\n      symbols[mod(index - 1, symbols.length)].repeat(\n        Math.ceil(index / symbols.length)\n      )\n    )\n      .withRange(1, Infinity)\n      .withMaxLengthComputer((min, max, defaultCmp) => {\n        // Just iterate over the last n elements until max, with n the number\n        // of symbols.\n        return defaultCmp(\n          max < symbols.length ? min : max - symbols.length,\n          max\n        );\n      }),\n  alphabetic: (...symbols) => {\n    return alphabetic(\n      makeCSRendererFromFormatter((index) => {\n        let result = '';\n        while (index > 0) {\n          index--;\n          result = symbols[mod(index, symbols.length)] + result;\n          index = Math.floor(index / symbols.length);\n        }\n        return result;\n      }),\n      symbols.length\n    );\n  },\n  numeric: (...symbols) => {\n    return numeric(\n      makeCSRendererFromFormatter((index) => {\n        if (index === 0) {\n          return symbols[0];\n        } else {\n          let result = '';\n          while (index > 0) {\n            result = symbols[mod(index, symbols.length)] + result;\n            index = Math.floor(index / symbols.length);\n          }\n          return result;\n        }\n      }),\n      symbols.length\n    );\n  },\n  numericFromUnicodeRange: (originUnicode: number, base: number) => {\n    return numeric(\n      makeCSRendererFromFormatter(\n        (index) =>\n          getAlphanumFromUnicodeRange(\n            index,\n            originUnicode,\n            base,\n            false\n          ) as string\n      ),\n      base\n    );\n  },\n  alphabeticFromUnicodeRange: (originUnicode: number, alphabetLen: number) => {\n    return alphabetic(\n      makeCSRendererFromFormatter((index) => {\n        return getAlphanumFromUnicodeRange(\n          index,\n          originUnicode,\n          alphabetLen,\n          true\n        );\n      }),\n      alphabetLen\n    );\n  },\n  additive: (symbols: { [value: number]: string }) => {\n    const values = Object.keys(symbols)\n      .map((value) => parseInt(value, 10))\n      .sort((a, b) => b - a);\n    return makeCSRendererFromFormatter((index) => {\n      if (index === 0) {\n        return symbols[0];\n      }\n      let result = '';\n      for (const value of values) {\n        if (index >= value && value > 0) {\n          const repeat = Math.floor(index / value);\n          result += symbols[value].repeat(repeat);\n          index -= repeat * value;\n        }\n      }\n      return index === 0 ? result : undefined;\n    }).withRange(\n      values.length ? values[values.length - 1] : 0,\n      0 in symbols && values.length === 1 ? 0 : values.length ? Infinity : -1\n    );\n  }\n});\n\nexport default CounterStyle;\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}