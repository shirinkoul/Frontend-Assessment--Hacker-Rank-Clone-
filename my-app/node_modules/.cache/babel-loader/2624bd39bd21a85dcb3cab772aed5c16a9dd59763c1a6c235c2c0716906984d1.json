{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = useImageConcreteDimensions;\nvar _react = require(\"react\");\nfunction extractHorizontalSpace(_ref) {\n  let {\n    marginHorizontal,\n    leftMargin,\n    rightMargin,\n    margin\n  } = _ref;\n  const realLeftMargin = leftMargin || marginHorizontal || margin || 0;\n  const realRightMargin = rightMargin || marginHorizontal || margin || 0;\n  return realLeftMargin + realRightMargin;\n}\nfunction scaleUp(minDimensions, desiredDimensions) {\n  const aspectRatio = desiredDimensions.width / desiredDimensions.height;\n  if (desiredDimensions.width < minDimensions.width) {\n    return scaleUp(minDimensions, {\n      width: minDimensions.width,\n      height: minDimensions.width / aspectRatio\n    });\n  }\n  if (desiredDimensions.height < minDimensions.height) {\n    return scaleUp(minDimensions, {\n      height: minDimensions.height,\n      width: minDimensions.height * aspectRatio\n    });\n  }\n  return desiredDimensions;\n}\nfunction scaleDown(maxDimensions, desiredDimensions) {\n  const aspectRatio = desiredDimensions.width / desiredDimensions.height;\n  if (desiredDimensions.width > maxDimensions.width) {\n    return scaleDown(maxDimensions, {\n      width: maxDimensions.width,\n      height: maxDimensions.width / aspectRatio\n    });\n  }\n  if (desiredDimensions.height > maxDimensions.height) {\n    return scaleDown(maxDimensions, {\n      height: maxDimensions.height,\n      width: maxDimensions.height * aspectRatio\n    });\n  }\n  return desiredDimensions;\n}\nfunction scale(_ref2, originalBox) {\n  let {\n    minBox,\n    maxBox\n  } = _ref2;\n  return scaleDown(maxBox, scaleUp(minBox, originalBox));\n}\nfunction computeConcreteDimensions(params) {\n  const {\n    computeMaxWidth,\n    contentWidth,\n    flattenStyles,\n    naturalWidth,\n    naturalHeight,\n    specifiedWidth,\n    specifiedHeight\n  } = params;\n  const horizontalSpace = extractHorizontalSpace(flattenStyles);\n  const {\n    maxWidth = Infinity,\n    maxHeight = Infinity,\n    minWidth = 0,\n    minHeight = 0\n  } = flattenStyles;\n  const imagesMaxWidth = typeof contentWidth === 'number' ? computeMaxWidth(contentWidth) : Infinity;\n  const minBox = {\n    width: minWidth,\n    height: minHeight\n  };\n  const maxBox = {\n    width: Math.min(imagesMaxWidth, maxWidth, typeof specifiedWidth === 'number' ? specifiedWidth : Infinity) - horizontalSpace,\n    height: Math.min(typeof specifiedHeight === 'number' ? specifiedHeight : Infinity, maxHeight)\n  };\n  if (typeof specifiedWidth === 'number' && typeof specifiedHeight === 'number') {\n    return scale({\n      minBox,\n      maxBox\n    }, {\n      width: specifiedWidth,\n      height: specifiedHeight\n    });\n  }\n  if (naturalWidth != null && naturalHeight != null) {\n    return scale({\n      minBox,\n      maxBox\n    }, {\n      width: naturalWidth,\n      height: naturalHeight\n    });\n  }\n  return null;\n}\nfunction useImageConcreteDimensions(_ref3) {\n  let {\n    flatStyle,\n    naturalDimensions,\n    specifiedDimensions,\n    computeMaxWidth,\n    contentWidth\n  } = _ref3;\n  return (0, _react.useMemo)(() => {\n    return computeConcreteDimensions({\n      flattenStyles: flatStyle,\n      computeMaxWidth,\n      contentWidth,\n      naturalWidth: naturalDimensions === null || naturalDimensions === void 0 ? void 0 : naturalDimensions.width,\n      naturalHeight: naturalDimensions === null || naturalDimensions === void 0 ? void 0 : naturalDimensions.height,\n      specifiedWidth: specifiedDimensions.width,\n      specifiedHeight: specifiedDimensions.height\n    });\n  }, [computeMaxWidth, contentWidth, flatStyle, naturalDimensions, specifiedDimensions.height, specifiedDimensions.width]);\n}","map":{"version":3,"mappings":"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","names":["extractHorizontalSpace","marginHorizontal","leftMargin","rightMargin","margin","realLeftMargin","realRightMargin","scaleUp","minDimensions","desiredDimensions","aspectRatio","width","height","scaleDown","maxDimensions","scale","originalBox","minBox","maxBox","computeConcreteDimensions","params","computeMaxWidth","contentWidth","flattenStyles","naturalWidth","naturalHeight","specifiedWidth","specifiedHeight","horizontalSpace","maxWidth","Infinity","maxHeight","minWidth","minHeight","imagesMaxWidth","Math","min","useImageConcreteDimensions","flatStyle","naturalDimensions","specifiedDimensions"],"sources":["/home/shirin/Desktop/Frontend Assessment- Hacker Rank Clone /node_modules/react-native-render-html/lib/commonjs/elements/useImageConcreteDimensions.ts"],"sourcesContent":["import { useMemo } from 'react';\nimport { ImageStyle } from 'react-native';\nimport { ImageDimensions } from '../shared-types';\nimport {\n  IncompleteImageDimensions,\n  UseIMGElementStateProps\n} from './img-types';\n\nexport type ConcreteDimensionsProps = {\n  flatStyle: ImageStyle;\n  naturalDimensions: ImageDimensions | null;\n  specifiedDimensions: IncompleteImageDimensions;\n} & Pick<UseIMGElementStateProps, 'computeMaxWidth' | 'contentWidth'>;\n\nfunction extractHorizontalSpace({\n  marginHorizontal,\n  leftMargin,\n  rightMargin,\n  margin\n}: any) {\n  const realLeftMargin = leftMargin || marginHorizontal || margin || 0;\n  const realRightMargin = rightMargin || marginHorizontal || margin || 0;\n  return realLeftMargin + realRightMargin;\n}\n\nfunction scaleUp(\n  minDimensions: ImageDimensions,\n  desiredDimensions: ImageDimensions\n): ImageDimensions {\n  const aspectRatio = desiredDimensions.width / desiredDimensions.height;\n  if (desiredDimensions.width < minDimensions.width) {\n    return scaleUp(minDimensions, {\n      width: minDimensions.width,\n      height: minDimensions.width / aspectRatio\n    });\n  }\n  if (desiredDimensions.height < minDimensions.height) {\n    return scaleUp(minDimensions, {\n      height: minDimensions.height,\n      width: minDimensions.height * aspectRatio\n    });\n  }\n  return desiredDimensions;\n}\n\nfunction scaleDown(\n  maxDimensions: ImageDimensions,\n  desiredDimensions: ImageDimensions\n): ImageDimensions {\n  const aspectRatio = desiredDimensions.width / desiredDimensions.height;\n  if (desiredDimensions.width > maxDimensions.width) {\n    return scaleDown(maxDimensions, {\n      width: maxDimensions.width,\n      height: maxDimensions.width / aspectRatio\n    });\n  }\n  if (desiredDimensions.height > maxDimensions.height) {\n    return scaleDown(maxDimensions, {\n      height: maxDimensions.height,\n      width: maxDimensions.height * aspectRatio\n    });\n  }\n  return desiredDimensions;\n}\n\nfunction scale(\n  { minBox, maxBox }: { maxBox: ImageDimensions; minBox: ImageDimensions },\n  originalBox: ImageDimensions\n) {\n  return scaleDown(maxBox, scaleUp(minBox, originalBox));\n}\n\nfunction computeConcreteDimensions(params: any) {\n  const {\n    computeMaxWidth,\n    contentWidth,\n    flattenStyles,\n    naturalWidth,\n    naturalHeight,\n    specifiedWidth,\n    specifiedHeight\n  } = params;\n  const horizontalSpace = extractHorizontalSpace(flattenStyles);\n  const {\n    maxWidth = Infinity,\n    maxHeight = Infinity,\n    minWidth = 0,\n    minHeight = 0\n  } = flattenStyles;\n  const imagesMaxWidth =\n    typeof contentWidth === 'number' ? computeMaxWidth(contentWidth) : Infinity;\n  const minBox = {\n    width: minWidth,\n    height: minHeight\n  };\n  const maxBox = {\n    width:\n      Math.min(\n        imagesMaxWidth,\n        maxWidth,\n        typeof specifiedWidth === 'number' ? specifiedWidth : Infinity\n      ) - horizontalSpace,\n    height: Math.min(\n      typeof specifiedHeight === 'number' ? specifiedHeight : Infinity,\n      maxHeight\n    )\n  };\n  if (\n    typeof specifiedWidth === 'number' &&\n    typeof specifiedHeight === 'number'\n  ) {\n    return scale(\n      { minBox, maxBox },\n      {\n        width: specifiedWidth,\n        height: specifiedHeight\n      }\n    );\n  }\n  if (naturalWidth != null && naturalHeight != null) {\n    return scale(\n      { minBox, maxBox },\n      {\n        width: naturalWidth,\n        height: naturalHeight\n      }\n    );\n  }\n  return null;\n}\n\nexport default function useImageConcreteDimensions<\n  P extends ConcreteDimensionsProps\n>({\n  flatStyle,\n  naturalDimensions,\n  specifiedDimensions,\n  computeMaxWidth,\n  contentWidth\n}: P): P['naturalDimensions'] extends ImageDimensions\n  ? ImageDimensions\n  : ImageDimensions | null {\n  return useMemo(() => {\n    return computeConcreteDimensions({\n      flattenStyles: flatStyle,\n      computeMaxWidth,\n      contentWidth,\n      naturalWidth: naturalDimensions?.width,\n      naturalHeight: naturalDimensions?.height,\n      specifiedWidth: specifiedDimensions.width,\n      specifiedHeight: specifiedDimensions.height\n    }) as any;\n  }, [\n    computeMaxWidth,\n    contentWidth,\n    flatStyle,\n    naturalDimensions,\n    specifiedDimensions.height,\n    specifiedDimensions.width\n  ]);\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}