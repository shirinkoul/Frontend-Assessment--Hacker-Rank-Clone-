{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _HTMLContentModel = _interopRequireDefault(require(\"./HTMLContentModel\"));\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nconst phrasingCategories = ['textual', 'edits', 'anchor'];\nconst translatableBlockCategories = ['tabular', 'grouping', 'sectioning'];\n/**\n * An object to specify custom tags.\n *\n * @typeParam T - The name of the tag to which the model will apply.\n * @typeParam M - The {@link HTMLContentModel} associated with this tag.\n */\n\n/**\n * An object defining engine internals for tags, such as default styles\n * (UAStyles), content model (how this tag is treated during hoisting)... etc.\n *\n * @typeParam T - The name of the tag to which the model will apply.\n * @typeParam M - The {@link HTMLContentModel} associated with this tag.\n */\nclass HTMLElementModel {\n  /**\n   * The tag name associated with this model.\n   */\n\n  /**\n   * The {@link HTMLContentModel} attached to this model.\n   */\n\n  /**\n   * An opaque element translated {@link TNode} will have no translated {@link TNode}\n   * children.\n   */\n\n  /**\n   * `true` when the associated tag is a {@link https://html.spec.whatwg.org/multipage/syntax.html#void-elements | void element}.\n   *\n   * @remarks\n   *\n   * - Void elements cannot have children.\n   * - TText-translated void elements will be preserved even though they don't\n   *   have children.\n   */\n\n  /**\n   * Equivalent of \"user-agent\" styles. The default styles for the element.\n   *\n   * @remarks These styles will be merged over by `tagsStyles`.\n   */\n\n  /**\n   * React Native props grouped by native components. Those props\n   * will be passed to the underlying native component at render time.\n   *\n   * @remarks Some props might be overriden by props derived from the\n   * {@link TNode} attributes. For example, if you pass `accessibilityLabel`\n   * and there is an `aria-label` attribute attached to one node, the\n   * `aria-label` will be used. If you want to be able to override the\n   * `aria-label`, use {@link HTMLElementModel.getReactNativeProps} instead.\n   *\n   * @example\n   *\n   * ```ts\n   * import {HTMLElementModel, HTMLContentModel} from 'react-native-render-html';\n   *\n   * const customHTMLElementModels = {\n   *  'nav-button': HTMLElementModel.fromCustomModel({\n   *    tagName: 'nav-button',\n   *    contentModel: HTMLContentModel.block,\n   *    reactNativeProps: {\n   *      native: {\n   *        onPress() {\n   *          console.info('nav-button pressed');\n   *        },\n   *      },\n   *    },\n   *  }),\n   *};\n   * ```\n   */\n\n  /**\n   * A function to create conditional \"user-agent\" styles.\n   *\n   * @deprecated Use {@link HTMLElementModel.getMixedUAStyles} instead.\n   */\n\n  /**\n   * A function to create conditional \"user-agent\" styles.\n   *\n   * @remarks For example, &lt;a&gt; tags will have underline decoration and be\n   * colored blue only when `href` is defined.\n   */\n\n  /**\n   * A function to create React Native props from a {@link TNode} grouped by\n   * native components.\n   *\n   * Those props will be deep-merged over the pre-generated props. You can\n   * preserve some of the pre-generated props since you receive them as second\n   * argument.\n   *\n   * **Merge strategy** (latest overrides former):\n   *\n   * 1. props from `reactNativeProps`,\n   * 2. auto-generated props from attributes\n   * 3. props returned by this function\n   *\n   * @param tnode - The {@link TNode} for which to create React Native props.\n   * @param preGeneratedProps - The props that were pre-generated for the {@link TNode}\n   * based on attributes (e.g. aria-label ...) and\n   * {@link ElementModelBase.reactNativeProps}.\n   * @returns React Native props grouped by native components (see\n   * {@link ReactNativePropsDefinitions}). Those props will be passed to the\n   * underlying native component at render time.\n   *\n   * @example\n   *\n   * ```ts\n   * import { defaultHTMLElementModels } from \"react-native-render-html\";\n   *\n   * const customHTMLElementModels = {\n   *   a: defaultHTMLElementModels.a.extend({\n   *     getReactNativeProps(tnode) {\n   *       const attributes = tnode.attributes;\n   *       return {\n   *         native: {\n   *           accessibilityHint:\n   *             attributes['data-scope'] === 'internal'\n   *               ? 'Open in a new screen.'\n   *               : 'Open in system web browser.',\n   *         },\n   *       };\n   *     },\n   *   }),\n   * };\n   * ```\n   */\n\n  /**\n   * Derive markers for one TNode.\n   */\n  constructor(_ref) {\n    let {\n      tagName,\n      contentModel,\n      isOpaque,\n      mixedUAStyles,\n      isVoid,\n      getUADerivedStyleFromAttributes,\n      getMixedUAStyles,\n      setMarkersForTNode,\n      getReactNativeProps,\n      reactNativeProps\n    } = _ref;\n    _defineProperty(this, \"tagName\", void 0);\n    _defineProperty(this, \"contentModel\", void 0);\n    _defineProperty(this, \"isOpaque\", void 0);\n    _defineProperty(this, \"isVoid\", void 0);\n    _defineProperty(this, \"mixedUAStyles\", void 0);\n    _defineProperty(this, \"reactNativeProps\", void 0);\n    _defineProperty(this, \"getUADerivedStyleFromAttributes\", void 0);\n    _defineProperty(this, \"getMixedUAStyles\", void 0);\n    _defineProperty(this, \"getReactNativeProps\", void 0);\n    _defineProperty(this, \"setMarkersForTNode\", void 0);\n    this.tagName = tagName;\n    this.contentModel = contentModel;\n    this.isOpaque = isOpaque || false;\n    this.isVoid = isVoid;\n    this.mixedUAStyles = mixedUAStyles;\n    this.getUADerivedStyleFromAttributes = getUADerivedStyleFromAttributes;\n    this.getMixedUAStyles = getMixedUAStyles;\n    this.setMarkersForTNode = setMarkersForTNode;\n    this.getReactNativeProps = getReactNativeProps;\n    this.reactNativeProps = reactNativeProps;\n  }\n  /**\n   * Create an {@link HTMLElementModel} from a custom template.\n   *\n   * @param template - The custom template.\n   */\n\n  static fromCustomModel(template) {\n    const {\n      contentModel,\n      tagName,\n      isOpaque = false,\n      isVoid = false,\n      ...optionalFields\n    } = template;\n    return new HTMLElementModel({\n      tagName,\n      contentModel,\n      isOpaque,\n      isVoid,\n      ...optionalFields\n    });\n  }\n  /**\n   * Create an {@link HTMLElementModel} from a native description.\n   *\n   * @param nativeElementModel - The native model declaration.\n   */\n\n  static fromNativeModel(nativeElementModel) {\n    const {\n      category,\n      isOpaque,\n      isVoid = false,\n      ...otherProps\n    } = nativeElementModel;\n    const isPhrasing = phrasingCategories.indexOf(category) !== -1;\n    const isTranslatable = isPhrasing || translatableBlockCategories.indexOf(category) !== -1;\n    const contentModel = category === 'anchor' || category === 'edits' ? _HTMLContentModel.default.mixed : isPhrasing ? _HTMLContentModel.default.textual : isTranslatable ? _HTMLContentModel.default.block : _HTMLContentModel.default.none;\n    return new HTMLElementModel({\n      isVoid,\n      contentModel: contentModel,\n      isOpaque: isOpaque !== null && isOpaque !== void 0 ? isOpaque : category === 'embedded',\n      ...otherProps\n    });\n  }\n  isTranslatableBlock() {\n    return this.contentModel === _HTMLContentModel.default.block;\n  }\n  isTranslatableTextual() {\n    return this.contentModel === _HTMLContentModel.default.textual || this.contentModel === _HTMLContentModel.default.mixed;\n  }\n  /**\n   * Create a new {@link HTMLElementModel} by shallow-merging properties into this model.\n   *\n   * @param merger - A function to generate the new properties to shallow-merge into this model.\n   * @typeParam CM - The {@link HTMLContentModel} attached to the new model.\n   */\n\n  extend(arg) {\n    const properties = typeof arg === 'function' ? arg(this) : arg;\n    return new HTMLElementModel({\n      ...this,\n      ...properties\n    });\n  }\n}\nexports.default = HTMLElementModel;","map":{"version":3,"mappings":";;;;;;AAIA;;;;;;;;;;;;;;;;;;;AASA,MAAMA,kBAAqC,GAAG,CAAC,SAAD,EAAY,OAAZ,EAAqB,QAArB,CAA9C;AACA,MAAMC,2BAA8C,GAAG,CACrD,SADqD,EAErD,UAFqD,EAGrD,YAHqD,CAAvD;AAMA;AACA;AACA;AACA;AACA;AACA;;AA0BA;AACA;AACA;AACA;AACA;AACA;AACA;AACe,MAAMC,gBAAN,CAIf;EACE;AACF;AACA;;EAEE;AACF;AACA;;EAEE;AACF;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAGE;AACF;AACA;EAGUC,WAAW,OAWa;IAAA,IAXZ;MAClBC,OADkB;MAElBC,YAFkB;MAGlBC,QAHkB;MAIlBC,aAJkB;MAKlBC,MALkB;MAMlBC,+BANkB;MAOlBC,gBAPkB;MAQlBC,kBARkB;MASlBC,mBATkB;MAUlBC;IAVkB,CAAD;IAWaC;IAAAA;IAAAA;IAAAA;IAAAA;IAAAA;IAAAA;IAAAA;IAAAA;IAAAA;IAC9B,KAAKV,OAAL,GAAeA,OAAf;IACA,KAAKC,YAAL,GAAoBA,YAApB;IACA,KAAKC,QAAL,GAAgBA,QAAQ,IAAI,KAA5B;IACA,KAAKE,MAAL,GAAcA,MAAd;IACA,KAAKD,aAAL,GAAqBA,aAArB;IACA,KAAKE,+BAAL,GAAuCA,+BAAvC;IACA,KAAKC,gBAAL,GAAwBA,gBAAxB;IACA,KAAKC,kBAAL,GAA0BA,kBAA1B;IACA,KAAKC,mBAAL,GAA2BA,mBAA3B;IACA,KAAKC,gBAAL,GAAwBA,gBAAxB;EACD;EAED;AACF;AACA;AACA;AACA;;EACwB,OAAfE,eAAe,CAGpBC,QAHoB,EAGoC;IACxD,MAAM;MACJX,YADI;MAEJD,OAFI;MAGJE,QAAQ,GAAG,KAHP;MAIJE,MAAM,GAAG,KAJL;MAKJ,GAAGS;IALC,IAMFD,QANJ;IAOA,OAAO,IAAId,gBAAJ,CAA+C;MACpDE,OADoD;MAEpDC,YAFoD;MAGpDC,QAHoD;MAIpDE,MAJoD;MAKpD,GAAGS;IALiD,CAA/C,CAAP;EAOD;EAED;AACF;AACA;AACA;AACA;;EACwB,OAAfC,eAAe,CACpBC,kBADoB,EAEpB;IACA,MAAM;MACJC,QADI;MAEJd,QAFI;MAGJE,MAAM,GAAG,KAHL;MAIJ,GAAGa;IAJC,IAKFF,kBALJ;IAMA,MAAMG,UAAU,GAAGtB,kBAAkB,CAACuB,OAAnB,CAA2BH,QAA3B,MAAyC,CAAC,CAA7D;IACA,MAAMI,cAAc,GAClBF,UAAU,IAAIrB,2BAA2B,CAACsB,OAA5B,CAAoCH,QAApC,MAAkD,CAAC,CADnE;IAEA,MAAMf,YAAY,GAChBe,QAAQ,KAAK,QAAb,IAAyBA,QAAQ,KAAK,OAAtC,GACIK,0BAAiBC,KADrB,GAEIJ,UAAU,GACVG,0BAAiBE,OADP,GAEVH,cAAc,GACdC,0BAAiBG,KADH,GAEdH,0BAAiBI,IAPvB;IAQA,OAAO,IAAI3B,gBAAJ,CASL;MACAM,MADA;MAEAH,YAAY,EAAEA,YAFd;MAGAC,QAAQ,EAAEA,QAAF,aAAEA,QAAF,cAAEA,QAAF,GAAcc,QAAQ,KAAK,UAHnC;MAIA,GAAGC;IAJH,CATK,CAAP;EAeD;EAEDS,mBAAmB,GAAY;IAC7B,OAAO,KAAKzB,YAAL,KAAsBoB,0BAAiBG,KAA9C;EACD;EAEDG,qBAAqB,GAAG;IACtB,OACE,KAAK1B,YAAL,KAAsBoB,0BAAiBE,OAAvC,IACA,KAAKtB,YAAL,KAAsBoB,0BAAiBC,KAFzC;EAID;EAED;AACF;AACA;AACA;AACA;AACA;;EAeEM,MAAM,CACJC,GADI,EAMqB;IACzB,MAAMC,UAAU,GAAG,OAAOD,GAAP,KAAe,UAAf,GAA4BA,GAAG,CAAC,IAAD,CAA/B,GAAwCA,GAA3D;IACA,OAAO,IAAI/B,gBAAJ,CAA4B;MACjC,GAAG,IAD8B;MAEjC,GAAGgC;IAF8B,CAA5B,CAAP;EAID;AAnQH","names":["phrasingCategories","translatableBlockCategories","HTMLElementModel","constructor","tagName","contentModel","isOpaque","mixedUAStyles","isVoid","getUADerivedStyleFromAttributes","getMixedUAStyles","setMarkersForTNode","getReactNativeProps","reactNativeProps","_defineProperty","fromCustomModel","template","optionalFields","fromNativeModel","nativeElementModel","category","otherProps","isPhrasing","indexOf","isTranslatable","HTMLContentModel","mixed","textual","block","none","isTranslatableBlock","isTranslatableTextual","extend","arg","properties"],"sources":["/home/shirin/Desktop/Frontend Assessment- Hacker Rank Clone /node_modules/@native-html/transient-render-engine/lib/commonjs/model/HTMLElementModel.ts"],"sourcesContent":["/* eslint-disable no-dupe-class-members */\nimport { MixedStyleDeclaration } from '@native-html/css-processor';\nimport { ReactNativePropsDefinitions } from '../helper-types';\nimport { SetMarkersForTNode } from '../tree/tree-types';\nimport HTMLContentModel from './HTMLContentModel';\nimport {\n  CustomElementModel,\n  ElementCategory,\n  ElementModelBase,\n  NativeElementModel,\n  TagName\n} from './model-types';\n\nconst phrasingCategories: ElementCategory[] = ['textual', 'edits', 'anchor'];\nconst translatableBlockCategories: ElementCategory[] = [\n  'tabular',\n  'grouping',\n  'sectioning'\n];\n\n/**\n * An object to specify custom tags.\n *\n * @typeParam T - The name of the tag to which the model will apply.\n * @typeParam M - The {@link HTMLContentModel} associated with this tag.\n */\nexport interface HTMLElementModelShape<\n  T extends string,\n  M extends HTMLContentModel\n> extends ElementModelBase<T> {\n  /**\n   * The {@link HTMLContentModel} attached to this model.\n   */\n  readonly contentModel: M;\n  /**\n   * `true` when the associated tag is a {@link https://html.spec.whatwg.org/multipage/syntax.html#void-elements | void element}.\n   *\n   * @remarks\n   *\n   * - Void elements cannot have children.\n   * - TText-translated void elements will be preserved even though they don't\n   *   have children.\n   */\n  readonly isVoid: boolean;\n  /**\n   * An opaque element translated {@link TNode} will have no translated {@link TNode}\n   * children.\n   */\n  readonly isOpaque: boolean;\n}\n\n/**\n * An object defining engine internals for tags, such as default styles\n * (UAStyles), content model (how this tag is treated during hoisting)... etc.\n *\n * @typeParam T - The name of the tag to which the model will apply.\n * @typeParam M - The {@link HTMLContentModel} associated with this tag.\n */\nexport default class HTMLElementModel<\n  T extends string,\n  M extends HTMLContentModel\n> implements HTMLElementModelShape<T, M>\n{\n  /**\n   * The tag name associated with this model.\n   */\n  public readonly tagName: T;\n  /**\n   * The {@link HTMLContentModel} attached to this model.\n   */\n  public readonly contentModel: M;\n  /**\n   * An opaque element translated {@link TNode} will have no translated {@link TNode}\n   * children.\n   */\n  public readonly isOpaque: boolean;\n  /**\n   * `true` when the associated tag is a {@link https://html.spec.whatwg.org/multipage/syntax.html#void-elements | void element}.\n   *\n   * @remarks\n   *\n   * - Void elements cannot have children.\n   * - TText-translated void elements will be preserved even though they don't\n   *   have children.\n   */\n  public readonly isVoid: boolean;\n  /**\n   * Equivalent of \"user-agent\" styles. The default styles for the element.\n   *\n   * @remarks These styles will be merged over by `tagsStyles`.\n   */\n  public readonly mixedUAStyles?: MixedStyleDeclaration;\n  /**\n   * React Native props grouped by native components. Those props\n   * will be passed to the underlying native component at render time.\n   *\n   * @remarks Some props might be overriden by props derived from the\n   * {@link TNode} attributes. For example, if you pass `accessibilityLabel`\n   * and there is an `aria-label` attribute attached to one node, the\n   * `aria-label` will be used. If you want to be able to override the\n   * `aria-label`, use {@link HTMLElementModel.getReactNativeProps} instead.\n   *\n   * @example\n   *\n   * ```ts\n   * import {HTMLElementModel, HTMLContentModel} from 'react-native-render-html';\n   *\n   * const customHTMLElementModels = {\n   *  'nav-button': HTMLElementModel.fromCustomModel({\n   *    tagName: 'nav-button',\n   *    contentModel: HTMLContentModel.block,\n   *    reactNativeProps: {\n   *      native: {\n   *        onPress() {\n   *          console.info('nav-button pressed');\n   *        },\n   *      },\n   *    },\n   *  }),\n   *};\n   * ```\n   */\n  readonly reactNativeProps?: ReactNativePropsDefinitions;\n  /**\n   * A function to create conditional \"user-agent\" styles.\n   *\n   * @deprecated Use {@link HTMLElementModel.getMixedUAStyles} instead.\n   */\n  public readonly getUADerivedStyleFromAttributes: NativeElementModel['getUADerivedStyleFromAttributes'];\n  /**\n   * A function to create conditional \"user-agent\" styles.\n   *\n   * @remarks For example, &lt;a&gt; tags will have underline decoration and be\n   * colored blue only when `href` is defined.\n   */\n  public readonly getMixedUAStyles: NativeElementModel['getMixedUAStyles'];\n  /**\n   * A function to create React Native props from a {@link TNode} grouped by\n   * native components.\n   *\n   * Those props will be deep-merged over the pre-generated props. You can\n   * preserve some of the pre-generated props since you receive them as second\n   * argument.\n   *\n   * **Merge strategy** (latest overrides former):\n   *\n   * 1. props from `reactNativeProps`,\n   * 2. auto-generated props from attributes\n   * 3. props returned by this function\n   *\n   * @param tnode - The {@link TNode} for which to create React Native props.\n   * @param preGeneratedProps - The props that were pre-generated for the {@link TNode}\n   * based on attributes (e.g. aria-label ...) and\n   * {@link ElementModelBase.reactNativeProps}.\n   * @returns React Native props grouped by native components (see\n   * {@link ReactNativePropsDefinitions}). Those props will be passed to the\n   * underlying native component at render time.\n   *\n   * @example\n   *\n   * ```ts\n   * import { defaultHTMLElementModels } from \"react-native-render-html\";\n   *\n   * const customHTMLElementModels = {\n   *   a: defaultHTMLElementModels.a.extend({\n   *     getReactNativeProps(tnode) {\n   *       const attributes = tnode.attributes;\n   *       return {\n   *         native: {\n   *           accessibilityHint:\n   *             attributes['data-scope'] === 'internal'\n   *               ? 'Open in a new screen.'\n   *               : 'Open in system web browser.',\n   *         },\n   *       };\n   *     },\n   *   }),\n   * };\n   * ```\n   */\n  public readonly getReactNativeProps: NativeElementModel['getReactNativeProps'];\n\n  /**\n   * Derive markers for one TNode.\n   */\n  public readonly setMarkersForTNode?: SetMarkersForTNode;\n\n  private constructor({\n    tagName,\n    contentModel,\n    isOpaque,\n    mixedUAStyles,\n    isVoid,\n    getUADerivedStyleFromAttributes,\n    getMixedUAStyles,\n    setMarkersForTNode,\n    getReactNativeProps,\n    reactNativeProps\n  }: HTMLElementModelShape<T, M>) {\n    this.tagName = tagName;\n    this.contentModel = contentModel;\n    this.isOpaque = isOpaque || false;\n    this.isVoid = isVoid;\n    this.mixedUAStyles = mixedUAStyles;\n    this.getUADerivedStyleFromAttributes = getUADerivedStyleFromAttributes;\n    this.getMixedUAStyles = getMixedUAStyles;\n    this.setMarkersForTNode = setMarkersForTNode;\n    this.getReactNativeProps = getReactNativeProps;\n    this.reactNativeProps = reactNativeProps;\n  }\n\n  /**\n   * Create an {@link HTMLElementModel} from a custom template.\n   *\n   * @param template - The custom template.\n   */\n  static fromCustomModel<\n    CustomTags extends string,\n    ContentModel extends HTMLContentModel\n  >(template: CustomElementModel<CustomTags, ContentModel>) {\n    const {\n      contentModel,\n      tagName,\n      isOpaque = false,\n      isVoid = false,\n      ...optionalFields\n    } = template;\n    return new HTMLElementModel<CustomTags, ContentModel>({\n      tagName,\n      contentModel,\n      isOpaque,\n      isVoid,\n      ...optionalFields\n    });\n  }\n\n  /**\n   * Create an {@link HTMLElementModel} from a native description.\n   *\n   * @param nativeElementModel - The native model declaration.\n   */\n  static fromNativeModel<TN extends TagName, E extends ElementCategory>(\n    nativeElementModel: NativeElementModel<TN, E>\n  ) {\n    const {\n      category,\n      isOpaque,\n      isVoid = false,\n      ...otherProps\n    } = nativeElementModel;\n    const isPhrasing = phrasingCategories.indexOf(category) !== -1;\n    const isTranslatable =\n      isPhrasing || translatableBlockCategories.indexOf(category) !== -1;\n    const contentModel =\n      category === 'anchor' || category === 'edits'\n        ? HTMLContentModel.mixed\n        : isPhrasing\n        ? HTMLContentModel.textual\n        : isTranslatable\n        ? HTMLContentModel.block\n        : HTMLContentModel.none;\n    return new HTMLElementModel<\n      TN,\n      E extends 'edits' | 'anchor'\n        ? HTMLContentModel.mixed\n        : E extends 'sectioning' | 'grouping' | 'tabular'\n        ? HTMLContentModel.block\n        : E extends 'textual'\n        ? HTMLContentModel.textual\n        : HTMLContentModel.none\n    >({\n      isVoid,\n      contentModel: contentModel as any,\n      isOpaque: isOpaque ?? category === 'embedded',\n      ...otherProps\n    });\n  }\n\n  isTranslatableBlock(): boolean {\n    return this.contentModel === HTMLContentModel.block;\n  }\n\n  isTranslatableTextual() {\n    return (\n      this.contentModel === HTMLContentModel.textual ||\n      this.contentModel === HTMLContentModel.mixed\n    );\n  }\n\n  /**\n   * Create a new {@link HTMLElementModel} by shallow-merging properties into this model.\n   *\n   * @param merger - A function to generate the new properties to shallow-merge into this model.\n   * @typeParam CM - The {@link HTMLContentModel} attached to the new model.\n   */\n  extend<CM extends HTMLContentModel>(\n    merger: (\n      shape: HTMLElementModelShape<T, CM>\n    ) => Partial<HTMLElementModelShape<T, CM>>\n  ): HTMLElementModel<T, CM>;\n  /**\n   * Create a new {@link HTMLElementModel} by shallow-merging properties into this model.\n   *\n   * @param shape - The {@link HTMLElementModelShape} to shallow-merge into this model.\n   * @typeParam CM - The {@link HTMLContentModel} attached to the new model.\n   */\n  extend<CM extends HTMLContentModel>(\n    shape: Partial<HTMLElementModelShape<T, CM>>\n  ): HTMLElementModel<T, CM>;\n  extend<CM extends HTMLContentModel>(\n    arg:\n      | ((\n          shape: HTMLElementModelShape<T, M>\n        ) => Partial<HTMLElementModelShape<T, CM>>)\n      | Partial<HTMLElementModelShape<T, CM>>\n  ): HTMLElementModel<T, CM> {\n    const properties = typeof arg === 'function' ? arg(this) : arg;\n    return new HTMLElementModel<T, CM>({\n      ...this,\n      ...properties\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}