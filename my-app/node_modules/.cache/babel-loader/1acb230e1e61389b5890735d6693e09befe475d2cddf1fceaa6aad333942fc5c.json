{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TPhrasingCtor = exports.default = void 0;\nvar _HTMLContentModel = _interopRequireDefault(require(\"../model/HTMLContentModel\"));\nvar _TNodeCtor = _interopRequireDefault(require(\"./TNodeCtor\"));\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction isChildEmpty(c) {\n  return c.isEmpty();\n}\nconst TPhrasingCtor = function TPhrasing(init) {\n  this.initialize(init);\n}; //@ts-ignore\n\nexports.TPhrasingCtor = TPhrasingCtor;\nTPhrasingCtor.prototype = new _TNodeCtor.default('phrasing', 'TPhrasing');\nTPhrasingCtor.prototype.matchContentModel = function matchContentModel(contentModel) {\n  return contentModel === _HTMLContentModel.default.textual || contentModel === _HTMLContentModel.default.mixed;\n};\nTPhrasingCtor.prototype.isEmpty = function isEmpty() {\n  // Only anonymous phrasing nodes with every children empty can be considered \"empty\"\n  return this.tagName === null && this.children.every(isChildEmpty);\n};\nTPhrasingCtor.prototype.collapseChildren = function collapseChildren() {\n  let previous = null;\n  this.children.forEach((childK, k) => {\n    const j = k - 1;\n    childK.collapse();\n    if (j > -1 && childK.isCollapsibleLeft() && previous.isCollapsibleRight()) {\n      // We must trim left from current to support trimming\n      // after <br> and <wbr> tags.\n      childK.trimLeft();\n    }\n    previous = childK;\n  });\n  this.trimLeft();\n  this.trimRight();\n  return null;\n};\nvar _default = TPhrasingCtor;\nexports.default = _default;","map":{"version":3,"mappings":";;;;;;AAAA;AACA;;;;;;AAKA,SAASA,YAAT,CAAsBC,CAAtB,EAAoC;EAClC,OAAOA,CAAC,CAACC,OAAF,EAAP;AACD;AAED,MAAMC,aAAa,GAAG,SAASC,SAAT,CAEpBC,IAFoB,EAGpB;EACA,KAAKC,UAAL,CAAgBD,IAAhB;AACD,CALD,C,CAOA;;;AACAF,aAAa,CAACI,SAAd,GAA0B,IAAIC,kBAAJ,CAAc,UAAd,EAA0B,WAA1B,CAA1B;AAEAL,aAAa,CAACI,SAAd,CAAwBE,iBAAxB,GAA4C,SAASA,iBAAT,CAC1CC,YAD0C,EAE1C;EACA,OACEA,YAAY,KAAKC,0BAAiBC,OAAlC,IACAF,YAAY,KAAKC,0BAAiBE,KAFpC;AAID,CAPD;AASAV,aAAa,CAACI,SAAd,CAAwBL,OAAxB,GAAkC,SAASA,OAAT,GAAmB;EACnD;EACA,OAAO,KAAKY,OAAL,KAAiB,IAAjB,IAAyB,KAAKC,QAAL,CAAcC,KAAd,CAAoBhB,YAApB,CAAhC;AACD,CAHD;AAKAG,aAAa,CAACI,SAAd,CAAwBU,gBAAxB,GAA2C,SAASA,gBAAT,GAA4B;EACrE,IAAIC,QAA0B,GAAG,IAAjC;EACA,KAAKH,QAAL,CAAcI,OAAd,CAAsB,CAACC,MAAD,EAASC,CAAT,KAAe;IACnC,MAAMC,CAAC,GAAGD,CAAC,GAAG,CAAd;IACAD,MAAM,CAACG,QAAP;IACA,IACED,CAAC,GAAG,CAAC,CAAL,IACAF,MAAM,CAACI,iBAAP,EADA,IAECN,QAAD,CAAwBO,kBAAxB,EAHF,EAIE;MACA;MACA;MACAL,MAAM,CAACM,QAAP;IACD;IACDR,QAAQ,GAAGE,MAAX;EACD,CAbD;EAcA,KAAKM,QAAL;EACA,KAAKC,SAAL;EACA,OAAO,IAAP;AACD,CAnBD;eAqBexB,a","names":["isChildEmpty","c","isEmpty","TPhrasingCtor","TPhrasing","init","initialize","prototype","TNodeCtor","matchContentModel","contentModel","HTMLContentModel","textual","mixed","tagName","children","every","collapseChildren","previous","forEach","childK","k","j","collapse","isCollapsibleLeft","isCollapsibleRight","trimLeft","trimRight"],"sources":["/home/shirin/Desktop/Frontend Assessment- Hacker Rank Clone /node_modules/@native-html/transient-render-engine/lib/commonjs/tree/TPhrasingCtor.ts"],"sourcesContent":["import HTMLContentModel from '../model/HTMLContentModel';\nimport TNodeCtor, { GenericTNodeCtor, Mutable } from './TNodeCtor';\nimport { TNodeImpl, TNodeInit } from './tree-types';\n\nexport interface TPhrasingImpl extends TNodeImpl {}\n\nfunction isChildEmpty(c: TNodeImpl) {\n  return c.isEmpty();\n}\n\nconst TPhrasingCtor = function TPhrasing(\n  this: Mutable<TNodeImpl>,\n  init: TNodeInit\n) {\n  this.initialize(init);\n} as Function as GenericTNodeCtor<TNodeInit, TPhrasingImpl>;\n\n//@ts-ignore\nTPhrasingCtor.prototype = new TNodeCtor('phrasing', 'TPhrasing');\n\nTPhrasingCtor.prototype.matchContentModel = function matchContentModel(\n  contentModel\n) {\n  return (\n    contentModel === HTMLContentModel.textual ||\n    contentModel === HTMLContentModel.mixed\n  );\n};\n\nTPhrasingCtor.prototype.isEmpty = function isEmpty() {\n  // Only anonymous phrasing nodes with every children empty can be considered \"empty\"\n  return this.tagName === null && this.children.every(isChildEmpty);\n};\n\nTPhrasingCtor.prototype.collapseChildren = function collapseChildren() {\n  let previous: TNodeImpl | null = null;\n  this.children.forEach((childK, k) => {\n    const j = k - 1;\n    childK.collapse();\n    if (\n      j > -1 &&\n      childK.isCollapsibleLeft() &&\n      (previous as TNodeImpl).isCollapsibleRight()\n    ) {\n      // We must trim left from current to support trimming\n      // after <br> and <wbr> tags.\n      childK.trimLeft();\n    }\n    previous = childK;\n  });\n  this.trimLeft();\n  this.trimRight();\n  return null;\n};\n\nexport default TPhrasingCtor;\n\nexport { TPhrasingCtor };\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}